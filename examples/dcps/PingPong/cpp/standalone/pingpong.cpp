//******************************************************************
// 
//  Generated by IDL to C++ Translator
//  
//  File name: pingpong.cpp
//  Source: ../../idl/pingpong.idl
//  Generated: Mon Oct 23 17:11:01 2017
//  OpenSplice 6.8.2
//  
//******************************************************************

#include "pingpong.h"

#if DDS_USE_EXPLICIT_TEMPLATES
template class DDS_DCPSBFLSeq < DDS::Boolean, DDS::Boolean, 10>;
#endif
#if DDS_USE_EXPLICIT_TEMPLATES
template class DDS_DCPSBFLSeq < DDS::Double, DDS::Double, 10>;
#endif
#if DDS_USE_EXPLICIT_TEMPLATES
template class DDS_DCPSBFLSeq < DDS::Float, DDS::Float, 10>;
#endif
#if DDS_USE_EXPLICIT_TEMPLATES
template class DDS_DCPSBFLSeq < DDS::ULongLong, DDS::ULongLong, 10>;
#endif
#if DDS_USE_EXPLICIT_TEMPLATES
template class DDS_DCPSBFLSeq < DDS::LongLong, DDS::LongLong, 10>;
#endif
#if DDS_USE_EXPLICIT_TEMPLATES
template class DDS_DCPSBFLSeq < DDS::ULong, DDS::ULong, 10>;
#endif
#if DDS_USE_EXPLICIT_TEMPLATES
template class DDS_DCPSBFLSeq < DDS::Long, DDS::Long, 10>;
#endif
#if DDS_USE_EXPLICIT_TEMPLATES
template class DDS_DCPSBFLSeq < DDS::UShort, DDS::UShort, 10>;
#endif
#if DDS_USE_EXPLICIT_TEMPLATES
template class DDS_DCPSBFLSeq < DDS::Short, DDS::Short, 10>;
#endif
#if DDS_USE_EXPLICIT_TEMPLATES
template class DDS_DCPSBFLSeq < DDS::Octet, DDS::Octet, 10>;
#endif
#if DDS_USE_EXPLICIT_TEMPLATES
template class DDS_DCPSBFLSeq < DDS::Char, DDS::Char, 10>;
#endif

#if DDS_USE_EXPLICIT_TEMPLATES
template class DDS_DCPS_FArray_var< pingpong::PP_array_msg::_str_arr_boolean, pingpong::PP_array_msg::_str_arr_boolean_slice, struct pingpong::PP_array_msg::_str_arr_boolean_uniq_>;
template class DDS_DCPS_Array_forany< pingpong::PP_array_msg::_str_arr_boolean, pingpong::PP_array_msg::_str_arr_boolean_slice, struct pingpong::PP_array_msg::_str_arr_boolean_uniq_>;
#endif

template <>
pingpong::PP_array_msg::_str_arr_boolean_slice* DDS_DCPS_ArrayHelper < pingpong::PP_array_msg::_str_arr_boolean, pingpong::PP_array_msg::_str_arr_boolean_slice, pingpong::PP_array_msg::_str_arr_boolean_uniq_>::alloc ()
{
   return pingpong::PP_array_msg::_str_arr_boolean_alloc ();
}

template <>
void DDS_DCPS_ArrayHelper < pingpong::PP_array_msg::_str_arr_boolean, pingpong::PP_array_msg::_str_arr_boolean_slice, pingpong::PP_array_msg::_str_arr_boolean_uniq_>::copy (pingpong::PP_array_msg::_str_arr_boolean_slice *to, const pingpong::PP_array_msg::_str_arr_boolean_slice* from)
{
   pingpong::PP_array_msg::_str_arr_boolean_copy (to, from);
}

template <>
void DDS_DCPS_ArrayHelper < pingpong::PP_array_msg::_str_arr_boolean, pingpong::PP_array_msg::_str_arr_boolean_slice, pingpong::PP_array_msg::_str_arr_boolean_uniq_>::free (pingpong::PP_array_msg::_str_arr_boolean_slice *ptr)
{
   pingpong::PP_array_msg::_str_arr_boolean_free (ptr);
}

pingpong::PP_array_msg::_str_arr_boolean_slice * pingpong::PP_array_msg::_str_arr_boolean_alloc ()
{
   DDS::Boolean * ret = (DDS::Boolean*) new DDS::Boolean [11];
   return (_str_arr_boolean_slice *) ret;
}

void pingpong::PP_array_msg::_str_arr_boolean_free (_str_arr_boolean_slice * s)
{
   delete [] s;
}

void pingpong::PP_array_msg::_str_arr_boolean_copy
(
   _str_arr_boolean_slice * to,
   const _str_arr_boolean_slice * from
)
{
   const DDS::Boolean* sv = ( const DDS::Boolean*) from;
   DDS::Boolean* tv = (DDS::Boolean*) to;
   for (DDS::ULong i = 0; i < 11; i++) tv[i] = sv[i];
}

pingpong::PP_array_msg::_str_arr_boolean_slice * pingpong::PP_array_msg::_str_arr_boolean_dup
   (const _str_arr_boolean_slice * from)
{
   _str_arr_boolean_slice * to = _str_arr_boolean_alloc ();
   _str_arr_boolean_copy (to, from);
   return to;
}


#if DDS_USE_EXPLICIT_TEMPLATES
template class DDS_DCPS_FArray_var< pingpong::PP_array_msg::_str_arr_double, pingpong::PP_array_msg::_str_arr_double_slice, struct pingpong::PP_array_msg::_str_arr_double_uniq_>;
template class DDS_DCPS_Array_forany< pingpong::PP_array_msg::_str_arr_double, pingpong::PP_array_msg::_str_arr_double_slice, struct pingpong::PP_array_msg::_str_arr_double_uniq_>;
#endif

template <>
pingpong::PP_array_msg::_str_arr_double_slice* DDS_DCPS_ArrayHelper < pingpong::PP_array_msg::_str_arr_double, pingpong::PP_array_msg::_str_arr_double_slice, pingpong::PP_array_msg::_str_arr_double_uniq_>::alloc ()
{
   return pingpong::PP_array_msg::_str_arr_double_alloc ();
}

template <>
void DDS_DCPS_ArrayHelper < pingpong::PP_array_msg::_str_arr_double, pingpong::PP_array_msg::_str_arr_double_slice, pingpong::PP_array_msg::_str_arr_double_uniq_>::copy (pingpong::PP_array_msg::_str_arr_double_slice *to, const pingpong::PP_array_msg::_str_arr_double_slice* from)
{
   pingpong::PP_array_msg::_str_arr_double_copy (to, from);
}

template <>
void DDS_DCPS_ArrayHelper < pingpong::PP_array_msg::_str_arr_double, pingpong::PP_array_msg::_str_arr_double_slice, pingpong::PP_array_msg::_str_arr_double_uniq_>::free (pingpong::PP_array_msg::_str_arr_double_slice *ptr)
{
   pingpong::PP_array_msg::_str_arr_double_free (ptr);
}

pingpong::PP_array_msg::_str_arr_double_slice * pingpong::PP_array_msg::_str_arr_double_alloc ()
{
   DDS::Double * ret = (DDS::Double*) new DDS::Double [10];
   return (_str_arr_double_slice *) ret;
}

void pingpong::PP_array_msg::_str_arr_double_free (_str_arr_double_slice * s)
{
   delete [] s;
}

void pingpong::PP_array_msg::_str_arr_double_copy
(
   _str_arr_double_slice * to,
   const _str_arr_double_slice * from
)
{
   const DDS::Double* sv = ( const DDS::Double*) from;
   DDS::Double* tv = (DDS::Double*) to;
   for (DDS::ULong i = 0; i < 10; i++) tv[i] = sv[i];
}

pingpong::PP_array_msg::_str_arr_double_slice * pingpong::PP_array_msg::_str_arr_double_dup
   (const _str_arr_double_slice * from)
{
   _str_arr_double_slice * to = _str_arr_double_alloc ();
   _str_arr_double_copy (to, from);
   return to;
}


#if DDS_USE_EXPLICIT_TEMPLATES
template class DDS_DCPS_FArray_var< pingpong::PP_array_msg::_str_arr_float, pingpong::PP_array_msg::_str_arr_float_slice, struct pingpong::PP_array_msg::_str_arr_float_uniq_>;
template class DDS_DCPS_Array_forany< pingpong::PP_array_msg::_str_arr_float, pingpong::PP_array_msg::_str_arr_float_slice, struct pingpong::PP_array_msg::_str_arr_float_uniq_>;
#endif

template <>
pingpong::PP_array_msg::_str_arr_float_slice* DDS_DCPS_ArrayHelper < pingpong::PP_array_msg::_str_arr_float, pingpong::PP_array_msg::_str_arr_float_slice, pingpong::PP_array_msg::_str_arr_float_uniq_>::alloc ()
{
   return pingpong::PP_array_msg::_str_arr_float_alloc ();
}

template <>
void DDS_DCPS_ArrayHelper < pingpong::PP_array_msg::_str_arr_float, pingpong::PP_array_msg::_str_arr_float_slice, pingpong::PP_array_msg::_str_arr_float_uniq_>::copy (pingpong::PP_array_msg::_str_arr_float_slice *to, const pingpong::PP_array_msg::_str_arr_float_slice* from)
{
   pingpong::PP_array_msg::_str_arr_float_copy (to, from);
}

template <>
void DDS_DCPS_ArrayHelper < pingpong::PP_array_msg::_str_arr_float, pingpong::PP_array_msg::_str_arr_float_slice, pingpong::PP_array_msg::_str_arr_float_uniq_>::free (pingpong::PP_array_msg::_str_arr_float_slice *ptr)
{
   pingpong::PP_array_msg::_str_arr_float_free (ptr);
}

pingpong::PP_array_msg::_str_arr_float_slice * pingpong::PP_array_msg::_str_arr_float_alloc ()
{
   DDS::Float * ret = (DDS::Float*) new DDS::Float [10];
   return (_str_arr_float_slice *) ret;
}

void pingpong::PP_array_msg::_str_arr_float_free (_str_arr_float_slice * s)
{
   delete [] s;
}

void pingpong::PP_array_msg::_str_arr_float_copy
(
   _str_arr_float_slice * to,
   const _str_arr_float_slice * from
)
{
   const DDS::Float* sv = ( const DDS::Float*) from;
   DDS::Float* tv = (DDS::Float*) to;
   for (DDS::ULong i = 0; i < 10; i++) tv[i] = sv[i];
}

pingpong::PP_array_msg::_str_arr_float_slice * pingpong::PP_array_msg::_str_arr_float_dup
   (const _str_arr_float_slice * from)
{
   _str_arr_float_slice * to = _str_arr_float_alloc ();
   _str_arr_float_copy (to, from);
   return to;
}


#if DDS_USE_EXPLICIT_TEMPLATES
template class DDS_DCPS_FArray_var< pingpong::PP_array_msg::_str_arr_ulonglong, pingpong::PP_array_msg::_str_arr_ulonglong_slice, struct pingpong::PP_array_msg::_str_arr_ulonglong_uniq_>;
template class DDS_DCPS_Array_forany< pingpong::PP_array_msg::_str_arr_ulonglong, pingpong::PP_array_msg::_str_arr_ulonglong_slice, struct pingpong::PP_array_msg::_str_arr_ulonglong_uniq_>;
#endif

template <>
pingpong::PP_array_msg::_str_arr_ulonglong_slice* DDS_DCPS_ArrayHelper < pingpong::PP_array_msg::_str_arr_ulonglong, pingpong::PP_array_msg::_str_arr_ulonglong_slice, pingpong::PP_array_msg::_str_arr_ulonglong_uniq_>::alloc ()
{
   return pingpong::PP_array_msg::_str_arr_ulonglong_alloc ();
}

template <>
void DDS_DCPS_ArrayHelper < pingpong::PP_array_msg::_str_arr_ulonglong, pingpong::PP_array_msg::_str_arr_ulonglong_slice, pingpong::PP_array_msg::_str_arr_ulonglong_uniq_>::copy (pingpong::PP_array_msg::_str_arr_ulonglong_slice *to, const pingpong::PP_array_msg::_str_arr_ulonglong_slice* from)
{
   pingpong::PP_array_msg::_str_arr_ulonglong_copy (to, from);
}

template <>
void DDS_DCPS_ArrayHelper < pingpong::PP_array_msg::_str_arr_ulonglong, pingpong::PP_array_msg::_str_arr_ulonglong_slice, pingpong::PP_array_msg::_str_arr_ulonglong_uniq_>::free (pingpong::PP_array_msg::_str_arr_ulonglong_slice *ptr)
{
   pingpong::PP_array_msg::_str_arr_ulonglong_free (ptr);
}

pingpong::PP_array_msg::_str_arr_ulonglong_slice * pingpong::PP_array_msg::_str_arr_ulonglong_alloc ()
{
   DDS::ULongLong * ret = (DDS::ULongLong*) new DDS::ULongLong [10];
   return (_str_arr_ulonglong_slice *) ret;
}

void pingpong::PP_array_msg::_str_arr_ulonglong_free (_str_arr_ulonglong_slice * s)
{
   delete [] s;
}

void pingpong::PP_array_msg::_str_arr_ulonglong_copy
(
   _str_arr_ulonglong_slice * to,
   const _str_arr_ulonglong_slice * from
)
{
   const DDS::ULongLong* sv = ( const DDS::ULongLong*) from;
   DDS::ULongLong* tv = (DDS::ULongLong*) to;
   for (DDS::ULong i = 0; i < 10; i++) tv[i] = sv[i];
}

pingpong::PP_array_msg::_str_arr_ulonglong_slice * pingpong::PP_array_msg::_str_arr_ulonglong_dup
   (const _str_arr_ulonglong_slice * from)
{
   _str_arr_ulonglong_slice * to = _str_arr_ulonglong_alloc ();
   _str_arr_ulonglong_copy (to, from);
   return to;
}


#if DDS_USE_EXPLICIT_TEMPLATES
template class DDS_DCPS_FArray_var< pingpong::PP_array_msg::_str_arr_longlong, pingpong::PP_array_msg::_str_arr_longlong_slice, struct pingpong::PP_array_msg::_str_arr_longlong_uniq_>;
template class DDS_DCPS_Array_forany< pingpong::PP_array_msg::_str_arr_longlong, pingpong::PP_array_msg::_str_arr_longlong_slice, struct pingpong::PP_array_msg::_str_arr_longlong_uniq_>;
#endif

template <>
pingpong::PP_array_msg::_str_arr_longlong_slice* DDS_DCPS_ArrayHelper < pingpong::PP_array_msg::_str_arr_longlong, pingpong::PP_array_msg::_str_arr_longlong_slice, pingpong::PP_array_msg::_str_arr_longlong_uniq_>::alloc ()
{
   return pingpong::PP_array_msg::_str_arr_longlong_alloc ();
}

template <>
void DDS_DCPS_ArrayHelper < pingpong::PP_array_msg::_str_arr_longlong, pingpong::PP_array_msg::_str_arr_longlong_slice, pingpong::PP_array_msg::_str_arr_longlong_uniq_>::copy (pingpong::PP_array_msg::_str_arr_longlong_slice *to, const pingpong::PP_array_msg::_str_arr_longlong_slice* from)
{
   pingpong::PP_array_msg::_str_arr_longlong_copy (to, from);
}

template <>
void DDS_DCPS_ArrayHelper < pingpong::PP_array_msg::_str_arr_longlong, pingpong::PP_array_msg::_str_arr_longlong_slice, pingpong::PP_array_msg::_str_arr_longlong_uniq_>::free (pingpong::PP_array_msg::_str_arr_longlong_slice *ptr)
{
   pingpong::PP_array_msg::_str_arr_longlong_free (ptr);
}

pingpong::PP_array_msg::_str_arr_longlong_slice * pingpong::PP_array_msg::_str_arr_longlong_alloc ()
{
   DDS::LongLong * ret = (DDS::LongLong*) new DDS::LongLong [10];
   return (_str_arr_longlong_slice *) ret;
}

void pingpong::PP_array_msg::_str_arr_longlong_free (_str_arr_longlong_slice * s)
{
   delete [] s;
}

void pingpong::PP_array_msg::_str_arr_longlong_copy
(
   _str_arr_longlong_slice * to,
   const _str_arr_longlong_slice * from
)
{
   const DDS::LongLong* sv = ( const DDS::LongLong*) from;
   DDS::LongLong* tv = (DDS::LongLong*) to;
   for (DDS::ULong i = 0; i < 10; i++) tv[i] = sv[i];
}

pingpong::PP_array_msg::_str_arr_longlong_slice * pingpong::PP_array_msg::_str_arr_longlong_dup
   (const _str_arr_longlong_slice * from)
{
   _str_arr_longlong_slice * to = _str_arr_longlong_alloc ();
   _str_arr_longlong_copy (to, from);
   return to;
}


#if DDS_USE_EXPLICIT_TEMPLATES
template class DDS_DCPS_FArray_var< pingpong::PP_array_msg::_str_arr_ulong, pingpong::PP_array_msg::_str_arr_ulong_slice, struct pingpong::PP_array_msg::_str_arr_ulong_uniq_>;
template class DDS_DCPS_Array_forany< pingpong::PP_array_msg::_str_arr_ulong, pingpong::PP_array_msg::_str_arr_ulong_slice, struct pingpong::PP_array_msg::_str_arr_ulong_uniq_>;
#endif

template <>
pingpong::PP_array_msg::_str_arr_ulong_slice* DDS_DCPS_ArrayHelper < pingpong::PP_array_msg::_str_arr_ulong, pingpong::PP_array_msg::_str_arr_ulong_slice, pingpong::PP_array_msg::_str_arr_ulong_uniq_>::alloc ()
{
   return pingpong::PP_array_msg::_str_arr_ulong_alloc ();
}

template <>
void DDS_DCPS_ArrayHelper < pingpong::PP_array_msg::_str_arr_ulong, pingpong::PP_array_msg::_str_arr_ulong_slice, pingpong::PP_array_msg::_str_arr_ulong_uniq_>::copy (pingpong::PP_array_msg::_str_arr_ulong_slice *to, const pingpong::PP_array_msg::_str_arr_ulong_slice* from)
{
   pingpong::PP_array_msg::_str_arr_ulong_copy (to, from);
}

template <>
void DDS_DCPS_ArrayHelper < pingpong::PP_array_msg::_str_arr_ulong, pingpong::PP_array_msg::_str_arr_ulong_slice, pingpong::PP_array_msg::_str_arr_ulong_uniq_>::free (pingpong::PP_array_msg::_str_arr_ulong_slice *ptr)
{
   pingpong::PP_array_msg::_str_arr_ulong_free (ptr);
}

pingpong::PP_array_msg::_str_arr_ulong_slice * pingpong::PP_array_msg::_str_arr_ulong_alloc ()
{
   DDS::ULong * ret = (DDS::ULong*) new DDS::ULong [10];
   return (_str_arr_ulong_slice *) ret;
}

void pingpong::PP_array_msg::_str_arr_ulong_free (_str_arr_ulong_slice * s)
{
   delete [] s;
}

void pingpong::PP_array_msg::_str_arr_ulong_copy
(
   _str_arr_ulong_slice * to,
   const _str_arr_ulong_slice * from
)
{
   const DDS::ULong* sv = ( const DDS::ULong*) from;
   DDS::ULong* tv = (DDS::ULong*) to;
   for (DDS::ULong i = 0; i < 10; i++) tv[i] = sv[i];
}

pingpong::PP_array_msg::_str_arr_ulong_slice * pingpong::PP_array_msg::_str_arr_ulong_dup
   (const _str_arr_ulong_slice * from)
{
   _str_arr_ulong_slice * to = _str_arr_ulong_alloc ();
   _str_arr_ulong_copy (to, from);
   return to;
}


#if DDS_USE_EXPLICIT_TEMPLATES
template class DDS_DCPS_FArray_var< pingpong::PP_array_msg::_str_arr_long, pingpong::PP_array_msg::_str_arr_long_slice, struct pingpong::PP_array_msg::_str_arr_long_uniq_>;
template class DDS_DCPS_Array_forany< pingpong::PP_array_msg::_str_arr_long, pingpong::PP_array_msg::_str_arr_long_slice, struct pingpong::PP_array_msg::_str_arr_long_uniq_>;
#endif

template <>
pingpong::PP_array_msg::_str_arr_long_slice* DDS_DCPS_ArrayHelper < pingpong::PP_array_msg::_str_arr_long, pingpong::PP_array_msg::_str_arr_long_slice, pingpong::PP_array_msg::_str_arr_long_uniq_>::alloc ()
{
   return pingpong::PP_array_msg::_str_arr_long_alloc ();
}

template <>
void DDS_DCPS_ArrayHelper < pingpong::PP_array_msg::_str_arr_long, pingpong::PP_array_msg::_str_arr_long_slice, pingpong::PP_array_msg::_str_arr_long_uniq_>::copy (pingpong::PP_array_msg::_str_arr_long_slice *to, const pingpong::PP_array_msg::_str_arr_long_slice* from)
{
   pingpong::PP_array_msg::_str_arr_long_copy (to, from);
}

template <>
void DDS_DCPS_ArrayHelper < pingpong::PP_array_msg::_str_arr_long, pingpong::PP_array_msg::_str_arr_long_slice, pingpong::PP_array_msg::_str_arr_long_uniq_>::free (pingpong::PP_array_msg::_str_arr_long_slice *ptr)
{
   pingpong::PP_array_msg::_str_arr_long_free (ptr);
}

pingpong::PP_array_msg::_str_arr_long_slice * pingpong::PP_array_msg::_str_arr_long_alloc ()
{
   DDS::Long * ret = (DDS::Long*) new DDS::Long [10];
   return (_str_arr_long_slice *) ret;
}

void pingpong::PP_array_msg::_str_arr_long_free (_str_arr_long_slice * s)
{
   delete [] s;
}

void pingpong::PP_array_msg::_str_arr_long_copy
(
   _str_arr_long_slice * to,
   const _str_arr_long_slice * from
)
{
   const DDS::Long* sv = ( const DDS::Long*) from;
   DDS::Long* tv = (DDS::Long*) to;
   for (DDS::ULong i = 0; i < 10; i++) tv[i] = sv[i];
}

pingpong::PP_array_msg::_str_arr_long_slice * pingpong::PP_array_msg::_str_arr_long_dup
   (const _str_arr_long_slice * from)
{
   _str_arr_long_slice * to = _str_arr_long_alloc ();
   _str_arr_long_copy (to, from);
   return to;
}


#if DDS_USE_EXPLICIT_TEMPLATES
template class DDS_DCPS_FArray_var< pingpong::PP_array_msg::_str_arr_ushort, pingpong::PP_array_msg::_str_arr_ushort_slice, struct pingpong::PP_array_msg::_str_arr_ushort_uniq_>;
template class DDS_DCPS_Array_forany< pingpong::PP_array_msg::_str_arr_ushort, pingpong::PP_array_msg::_str_arr_ushort_slice, struct pingpong::PP_array_msg::_str_arr_ushort_uniq_>;
#endif

template <>
pingpong::PP_array_msg::_str_arr_ushort_slice* DDS_DCPS_ArrayHelper < pingpong::PP_array_msg::_str_arr_ushort, pingpong::PP_array_msg::_str_arr_ushort_slice, pingpong::PP_array_msg::_str_arr_ushort_uniq_>::alloc ()
{
   return pingpong::PP_array_msg::_str_arr_ushort_alloc ();
}

template <>
void DDS_DCPS_ArrayHelper < pingpong::PP_array_msg::_str_arr_ushort, pingpong::PP_array_msg::_str_arr_ushort_slice, pingpong::PP_array_msg::_str_arr_ushort_uniq_>::copy (pingpong::PP_array_msg::_str_arr_ushort_slice *to, const pingpong::PP_array_msg::_str_arr_ushort_slice* from)
{
   pingpong::PP_array_msg::_str_arr_ushort_copy (to, from);
}

template <>
void DDS_DCPS_ArrayHelper < pingpong::PP_array_msg::_str_arr_ushort, pingpong::PP_array_msg::_str_arr_ushort_slice, pingpong::PP_array_msg::_str_arr_ushort_uniq_>::free (pingpong::PP_array_msg::_str_arr_ushort_slice *ptr)
{
   pingpong::PP_array_msg::_str_arr_ushort_free (ptr);
}

pingpong::PP_array_msg::_str_arr_ushort_slice * pingpong::PP_array_msg::_str_arr_ushort_alloc ()
{
   DDS::UShort * ret = (DDS::UShort*) new DDS::UShort [10];
   return (_str_arr_ushort_slice *) ret;
}

void pingpong::PP_array_msg::_str_arr_ushort_free (_str_arr_ushort_slice * s)
{
   delete [] s;
}

void pingpong::PP_array_msg::_str_arr_ushort_copy
(
   _str_arr_ushort_slice * to,
   const _str_arr_ushort_slice * from
)
{
   const DDS::UShort* sv = ( const DDS::UShort*) from;
   DDS::UShort* tv = (DDS::UShort*) to;
   for (DDS::ULong i = 0; i < 10; i++) tv[i] = sv[i];
}

pingpong::PP_array_msg::_str_arr_ushort_slice * pingpong::PP_array_msg::_str_arr_ushort_dup
   (const _str_arr_ushort_slice * from)
{
   _str_arr_ushort_slice * to = _str_arr_ushort_alloc ();
   _str_arr_ushort_copy (to, from);
   return to;
}


#if DDS_USE_EXPLICIT_TEMPLATES
template class DDS_DCPS_FArray_var< pingpong::PP_array_msg::_str_arr_short, pingpong::PP_array_msg::_str_arr_short_slice, struct pingpong::PP_array_msg::_str_arr_short_uniq_>;
template class DDS_DCPS_Array_forany< pingpong::PP_array_msg::_str_arr_short, pingpong::PP_array_msg::_str_arr_short_slice, struct pingpong::PP_array_msg::_str_arr_short_uniq_>;
#endif

template <>
pingpong::PP_array_msg::_str_arr_short_slice* DDS_DCPS_ArrayHelper < pingpong::PP_array_msg::_str_arr_short, pingpong::PP_array_msg::_str_arr_short_slice, pingpong::PP_array_msg::_str_arr_short_uniq_>::alloc ()
{
   return pingpong::PP_array_msg::_str_arr_short_alloc ();
}

template <>
void DDS_DCPS_ArrayHelper < pingpong::PP_array_msg::_str_arr_short, pingpong::PP_array_msg::_str_arr_short_slice, pingpong::PP_array_msg::_str_arr_short_uniq_>::copy (pingpong::PP_array_msg::_str_arr_short_slice *to, const pingpong::PP_array_msg::_str_arr_short_slice* from)
{
   pingpong::PP_array_msg::_str_arr_short_copy (to, from);
}

template <>
void DDS_DCPS_ArrayHelper < pingpong::PP_array_msg::_str_arr_short, pingpong::PP_array_msg::_str_arr_short_slice, pingpong::PP_array_msg::_str_arr_short_uniq_>::free (pingpong::PP_array_msg::_str_arr_short_slice *ptr)
{
   pingpong::PP_array_msg::_str_arr_short_free (ptr);
}

pingpong::PP_array_msg::_str_arr_short_slice * pingpong::PP_array_msg::_str_arr_short_alloc ()
{
   DDS::Short * ret = (DDS::Short*) new DDS::Short [10];
   return (_str_arr_short_slice *) ret;
}

void pingpong::PP_array_msg::_str_arr_short_free (_str_arr_short_slice * s)
{
   delete [] s;
}

void pingpong::PP_array_msg::_str_arr_short_copy
(
   _str_arr_short_slice * to,
   const _str_arr_short_slice * from
)
{
   const DDS::Short* sv = ( const DDS::Short*) from;
   DDS::Short* tv = (DDS::Short*) to;
   for (DDS::ULong i = 0; i < 10; i++) tv[i] = sv[i];
}

pingpong::PP_array_msg::_str_arr_short_slice * pingpong::PP_array_msg::_str_arr_short_dup
   (const _str_arr_short_slice * from)
{
   _str_arr_short_slice * to = _str_arr_short_alloc ();
   _str_arr_short_copy (to, from);
   return to;
}


#if DDS_USE_EXPLICIT_TEMPLATES
template class DDS_DCPS_FArray_var< pingpong::PP_array_msg::_str_arr_octet, pingpong::PP_array_msg::_str_arr_octet_slice, struct pingpong::PP_array_msg::_str_arr_octet_uniq_>;
template class DDS_DCPS_Array_forany< pingpong::PP_array_msg::_str_arr_octet, pingpong::PP_array_msg::_str_arr_octet_slice, struct pingpong::PP_array_msg::_str_arr_octet_uniq_>;
#endif

template <>
pingpong::PP_array_msg::_str_arr_octet_slice* DDS_DCPS_ArrayHelper < pingpong::PP_array_msg::_str_arr_octet, pingpong::PP_array_msg::_str_arr_octet_slice, pingpong::PP_array_msg::_str_arr_octet_uniq_>::alloc ()
{
   return pingpong::PP_array_msg::_str_arr_octet_alloc ();
}

template <>
void DDS_DCPS_ArrayHelper < pingpong::PP_array_msg::_str_arr_octet, pingpong::PP_array_msg::_str_arr_octet_slice, pingpong::PP_array_msg::_str_arr_octet_uniq_>::copy (pingpong::PP_array_msg::_str_arr_octet_slice *to, const pingpong::PP_array_msg::_str_arr_octet_slice* from)
{
   pingpong::PP_array_msg::_str_arr_octet_copy (to, from);
}

template <>
void DDS_DCPS_ArrayHelper < pingpong::PP_array_msg::_str_arr_octet, pingpong::PP_array_msg::_str_arr_octet_slice, pingpong::PP_array_msg::_str_arr_octet_uniq_>::free (pingpong::PP_array_msg::_str_arr_octet_slice *ptr)
{
   pingpong::PP_array_msg::_str_arr_octet_free (ptr);
}

pingpong::PP_array_msg::_str_arr_octet_slice * pingpong::PP_array_msg::_str_arr_octet_alloc ()
{
   DDS::Octet * ret = (DDS::Octet*) new DDS::Octet [10];
   return (_str_arr_octet_slice *) ret;
}

void pingpong::PP_array_msg::_str_arr_octet_free (_str_arr_octet_slice * s)
{
   delete [] s;
}

void pingpong::PP_array_msg::_str_arr_octet_copy
(
   _str_arr_octet_slice * to,
   const _str_arr_octet_slice * from
)
{
   const DDS::Octet* sv = ( const DDS::Octet*) from;
   DDS::Octet* tv = (DDS::Octet*) to;
   for (DDS::ULong i = 0; i < 10; i++) tv[i] = sv[i];
}

pingpong::PP_array_msg::_str_arr_octet_slice * pingpong::PP_array_msg::_str_arr_octet_dup
   (const _str_arr_octet_slice * from)
{
   _str_arr_octet_slice * to = _str_arr_octet_alloc ();
   _str_arr_octet_copy (to, from);
   return to;
}


#if DDS_USE_EXPLICIT_TEMPLATES
template class DDS_DCPS_FArray_var< pingpong::PP_array_msg::_str_arr_char, pingpong::PP_array_msg::_str_arr_char_slice, struct pingpong::PP_array_msg::_str_arr_char_uniq_>;
template class DDS_DCPS_Array_forany< pingpong::PP_array_msg::_str_arr_char, pingpong::PP_array_msg::_str_arr_char_slice, struct pingpong::PP_array_msg::_str_arr_char_uniq_>;
#endif

template <>
pingpong::PP_array_msg::_str_arr_char_slice* DDS_DCPS_ArrayHelper < pingpong::PP_array_msg::_str_arr_char, pingpong::PP_array_msg::_str_arr_char_slice, pingpong::PP_array_msg::_str_arr_char_uniq_>::alloc ()
{
   return pingpong::PP_array_msg::_str_arr_char_alloc ();
}

template <>
void DDS_DCPS_ArrayHelper < pingpong::PP_array_msg::_str_arr_char, pingpong::PP_array_msg::_str_arr_char_slice, pingpong::PP_array_msg::_str_arr_char_uniq_>::copy (pingpong::PP_array_msg::_str_arr_char_slice *to, const pingpong::PP_array_msg::_str_arr_char_slice* from)
{
   pingpong::PP_array_msg::_str_arr_char_copy (to, from);
}

template <>
void DDS_DCPS_ArrayHelper < pingpong::PP_array_msg::_str_arr_char, pingpong::PP_array_msg::_str_arr_char_slice, pingpong::PP_array_msg::_str_arr_char_uniq_>::free (pingpong::PP_array_msg::_str_arr_char_slice *ptr)
{
   pingpong::PP_array_msg::_str_arr_char_free (ptr);
}

pingpong::PP_array_msg::_str_arr_char_slice * pingpong::PP_array_msg::_str_arr_char_alloc ()
{
   DDS::Char * ret = (DDS::Char*) new DDS::Char [10];
   return (_str_arr_char_slice *) ret;
}

void pingpong::PP_array_msg::_str_arr_char_free (_str_arr_char_slice * s)
{
   delete [] s;
}

void pingpong::PP_array_msg::_str_arr_char_copy
(
   _str_arr_char_slice * to,
   const _str_arr_char_slice * from
)
{
   const DDS::Char* sv = ( const DDS::Char*) from;
   DDS::Char* tv = (DDS::Char*) to;
   for (DDS::ULong i = 0; i < 10; i++) tv[i] = sv[i];
}

pingpong::PP_array_msg::_str_arr_char_slice * pingpong::PP_array_msg::_str_arr_char_dup
   (const _str_arr_char_slice * from)
{
   _str_arr_char_slice * to = _str_arr_char_alloc ();
   _str_arr_char_copy (to, from);
   return to;
}

#if DDS_USE_EXPLICIT_TEMPLATES
template class DDS_DCPSUFLSeq < DDS::Char, struct seq_char_uniq_>;
#endif



